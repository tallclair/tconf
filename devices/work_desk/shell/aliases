#!/bin/bash

# Kubernetes
alias k8s-e2e='kubetest -v'
alias k8s-run-e2e='make WHAT=test/e2e/e2e.test && KUBERNETES_CONFORMANCE_TEST=y hack/ginkgo-e2e.sh --ginkgo.focus'
alias k8s-make-e2e='bazel build //test/e2e:e2e.test_binary //vendor/github.com/onsi/ginkgo/ginkgo:ginkgo'
function k8s-e2e-run() {
  if [[ $# == 0 ]]; then
    kubetest --check-version-skew=false --test $@
  else
    kubetest --check-version-skew=false --test --test_args="--ginkgo.focus=${1// /\\s}" ${@:2}
  fi
}

function k8s-node() {
  # 0 is master, default to 1
  INDEX=${1:-1}
  kubectl get nodes -o=jsonpath="{.items[$INDEX].metadata.name}"
}

function k8s-node-zone() {
  NODE=${1:-$(k8s-node)}
  kubectl get node $NODE -o=go-template='{{index .metadata.labels "failure-domain.beta.kubernetes.io/zone"}}'
}

function k8s-node-proxy() {
  if [[ $# == 0 ]]; then
    NODE=$(k8s-node)
  else
    NODE=$1
  fi
  echo "localhost:8001/api/v1/proxy/nodes/$NODE:10250"
}

function k8s-node-ssh() {
  NODE=${1:-$(k8s-node)}
  ZONE=$(k8s-node-zone $NODE)
  gcloud compute ssh --zone=$ZONE $NODE
}

function gogo() {
  local PROJECT="$1"
  local PROJECT_DIR=""
  local BASE="$HOME/go/$PROJECT"

  case $PROJECT in
    k8s*)
      PROJECT_DIR="$BASE/src/k8s.io/kubernetes"
      # Change over path to new project.
      local -r wild_project="${PROJECT_DIR//\/go\/k8s?\/src\//\/go\/k8s?\/src\/}"
      local -r wild_pattern="${wild_project//\//\\\/}"
      export PATH="${PATH//$wild_pattern/$PROJECT_DIR}"
      # Add etcd to path if it's not already there.
      if [[ ! $PATH =~ k8s.io/kubernetes/third_party/etcd ]]; then
        export PATH="$PROJECT_DIR/third_party/etcd:$PATH"
      fi
      ;;
    heapster)
      PROJECT_DIR="$BASE/src/k8s.io/heapster"
      ;;
    cadvisor)
      PROJECT_DIR="$BASE/src/github.com/google/cadvisor"
      ;;
    *)
      echo "Unknown go project '$PROJECT'" 1>&2
      return
      ;;
  esac
  export GOPATH="$BASE"
  export __G_PROJECT="$PROJECT"
  export __G_PROJECT_DIR="$PROJECT_DIR"
  cd $__G_PROJECT_DIR
}
alias gg='gogo'

# Grab log files
function k8s-kubelet-log() {
  NODE=${1:-$(k8s-node)}
  ZONE=$(k8s-node-zone $NODE)
  DATE="$(date +%y.%m.%d.%H%M)"
  DST="$HOME/logs/kubelet_$NODE_${DATE}.log"
  echo "Copying $NODE kubelet.log to $DST ..."
  gcloud compute copy-files --zone=$ZONE "${NODE}:/var/log/kubelet.log" "$DST"
}

# Grep for a branch across k8s{1,2,3}
function k8s-branch() {
  pushd . > /dev/null
  RESULT=1
  for BR in k8s{1,2,3}; do
    cd "$HOME/go/$BR/src/k8s.io/kubernetes"
    git branch | awk "{print \"$BR:\", \$0}" | grep $*
    RESULT=$((RESULT * $?))
  done
  popd > /dev/null
  return $RESULT
}

# Build Kubelet & update in-place on Kind
function kind-update-kubelet() {
  if ! grep -q '^module k8s.io/kubernetes$' go.mod; then
    echo "Must be executed from Kubernetes root directory"
    return 1
  fi

  if ! make WHAT="cmd/kubelet"; then
    return 1
  fi

  KUBELET="_output/bin/kubelet"
  if [ ! -x $KUBELET ]; then
    echo "Kubelet binary not found at $KUBELET"
    return 1
  fi

  for n in $(kind get nodes); do
    docker cp ${KUBELET} $n:/usr/bin/kubelet && \
      docker exec $n systemctl restart kubelet && \
      echo "Updated kubelet on node $n" || echo "Failed to update kubelet on node $n"
  done
}
alias kind-test-e2e='make WHAT="test/e2e/e2e.test" && ./_output/bin/e2e.test -context kind-kind -ginkgo.focus="${FOCUS// /\\s}" -num-nodes 2'
alias kind-test-e2e-rerun='./_output/bin/e2e.test -context kind-kind -ginkgo.focus="${FOCUS// /\\s}" -num-nodes 2'
alias kind-create-e2e-cluster='kind create cluster --config ${HOME}/src/github.com/tallclair/k8s-devel/config/kind-e2e-config.yaml --image kindest/node:latest'

# K8s deploy environment
alias k8s-env='echo ${K8S_ENV:-default}'
alias k8s-env-small='source $HOME/k8s/devel/config/config-small.sh && k8s-env'

# Go aliases
alias ago='ag --ignore "*_test.go" --ignore Godeps --ignore vendor -G ".*\.go$"'
alias ago-test='ag --ignore Godeps -G ".*_test\.go$"'
alias godep-test-dir='. $HOME/k8s/devel/scripts/godep-test-dir.sh'

alias graph-png="dot -Tpng -o /tmp/graph.png && google-chrome /tmp/graph.png"
alias graph-svg="dot -Tsvg -o /tmp/graph.svg && google-chrome /tmp/graph.svg"

alias k-use-ns='kubectl config set-context --current --namespace'

# Common typos
alias kuebctl='kubectl'


# go-test
# Description:
#   A wrapper for 'gotestsum' that allows running tests on specific subsets of
#   files based on their git status.
#
# Arguments:
#   -s, --staged       Run tests for packages containing staged .go files.
#   -c, --changed      Run tests for packages containing .go files that have 
#                      changed compared to a branch (default: upstream/master).
#                      Usage: go-test -c [branch_name]
#   -r, --recursive    If set, appends '/...' to package paths to run tests 
#                      recursively in subdirectories.
#   [args...]          Any other arguments are passed directly to gotestsum.
#
# Examples:
#   go-test -s                  # Test staged packages
#   go-test -c -r               # Recursive test on all changes vs upstream/master
#   go-test -c main             # Test changes vs 'main' branch
#   go-test -count=1 ./pkg/...  # Standard manual usage
go-test() {
  local mode=""
  local recursive=false
  local target_branch="upstream/master"
  local pass_through_args=()

  # --- 1. Argument Parsing ---
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -s|--staged)
        mode="staged"
        shift
        ;;
      -c|--changed)
        mode="changed"
        shift
        # Check if the next argument is a branch name (and not another flag)
        if [[ -n "$1" && "$1" != -* ]]; then
          target_branch="$1"
          shift
        fi
        ;;
      -r|--recursive)
        recursive=true
        shift
        ;;
      *)
        # Collect unknown args to pass to gotestsum (e.g., -v, -run)
        pass_through_args+=("$1")
        shift
        ;;
    esac
  done

  # --- 2. Identify Changed Files ---
  local changed_files=""
  
  if [[ "$mode" == "staged" ]]; then
    changed_files=$(git diff --name-only --cached | grep '\.go$')
  elif [[ "$mode" == "changed" ]]; then
    changed_files=$(git diff --name-only "$target_branch" | grep '\.go$')
  fi

  # If a mode was selected but no .go files changed, exit early
  if [[ -n "$mode" && -z "$changed_files" ]]; then
    echo "No .go files found in $mode changes."
    return 0
  fi

  # --- 3. Convert Files to Package Paths ---
  local pkg_list=""
  
  # Only process directories if we actually found files (or if no mode was set)
  if [[ -n "$changed_files" ]]; then
    # Get dirnames, unique them, and format as relative paths (./path)
    pkg_list=$(echo "$changed_files" | xargs dirname | sort -u | sed 's|^|./|')
    
    # Apply recursive flag if requested
    if [ "$recursive" = true ]; then
      pkg_list=$(echo "$pkg_list" | sed 's|$|/...|')
    fi
  fi

  # --- 4. Execution ---
  # If pkg_list is empty here, we are in "standard" mode (no -s or -c flags),
  # so we don't pass any paths, letting go test run in the current dir.
  
  # We use tr to replace newlines with spaces so the shell sees them as separate args
  gotestsum --format=pkgname-and-test-fails --format-icons=hivis -- \
            "${pass_through_args[@]}" $(echo "$pkg_list" | tr '\n' ' ')
}
